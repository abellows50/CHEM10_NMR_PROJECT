from vispy import scene
from vispy.visuals import transforms
import numpy as np

### Helper Functions ###
def magnitude(vector):
    return np.sqrt(np.dot(vector,vector))

### Simultation Configuration ###
M = np.array([0.2,0.,0.64]) # Net Magnitization Vector
M0 = magnitude(M)
B = np.array([1.,1.,5.]) # Magnetic Field Vector (points in the positive z direction)

T2 = 0.5 # Transverse Relaxation Time Constant
T1 = 1 # Longitudinal Relaxation Time Constant
R1 = 1/T1 # Relaxtation constant
R2 = 1/T2 # Relaxtation constant
gamma = 10 # Gyromagnetic ratio
dt = 0.001 # change in time per step
ORIGIN = np.array([0,0,0]) # Origin of our world

## This function takes the current net magnetization, starting magnetization, B field, both decay constants and the gyromagnetic ratio
## It returns the differential of M computed via the Bloch equations
## This function appears to be highly sensitive to input for certain M,B,R,gamma values. I believe this is a sensitive dependence on
## initial conditions problem
def calculate_bloch_differentials(M:np.array, M0:np.array, B:np.array, R1:float, R2:float, gamma:float) -> np.array:
    dmxdt = gamma*np.cross(M,B)[0] - R2*M[0]
    dmydt = gamma*np.cross(M,B)[1] - R2*M[1]
    dmzdt = gamma*np.cross(M,B)[2] - R1*(M[2]-M0)
    
    dM = np.array([dmxdt, dmydt, dmzdt])

    return dM

## This function computed the dext value of M after dt passes
def compute_next_state(M, M0, B, R1, R2, gamma) -> np.array:
    M += calculate_bloch_differentials(M,M0, B,R1,R2,gamma) * dt
    return M


### Graphics Setup (Generated by chatGPT from example code on vispy)
# Create a window and 3D camera
canvas = scene.SceneCanvas(keys='interactive', bgcolor='black', size=(800, 600), show=True)
view = canvas.central_widget.add_view()
view.camera = 'turntable'  # interactive orbit camera
### END GPT ZONE


# show the path that M takes through the scene
scatter = scene.visuals.Markers(parent=view.scene)

# track the location of M
vector = scene.visuals.Arrow(
        pos=np.vstack([ORIGIN, (ORIGIN + M)]), 
        width=2,
        color='cyan',
        parent=view.scene
    )

# show the constant B field
B_field = scene.visuals.Arrow(
        pos=np.vstack([ORIGIN, (ORIGIN + B)/magnitude(ORIGIN+B)]), #Normalize the B Field Bector
        width=2,
        color='red',
        parent=view.scene
    )

# axis = scene.visuals.XYZAxis(parent=view.scene)

plot_point = 0
PLOT_RATE = 2
points = []

created_second_b = False
# Animation function â€” updates every frame
def update(event):
    global M
    global B
    global plot_point
    global PLOT_RATE
    t = event.elapsed

    # advance our simulation
    M = compute_next_state(M, M0, B, R1, R2, gamma)

    plot_point += 1
    plot_point %= PLOT_RATE
    PLOT_RATE = int(t / 10 + 2)
    if plot_point == 0:
        
        points.append((M[0],M[1],M[2])) 
        plot = np.array(points)
        scatter.set_data(plot, face_color=(0.3,1,1), size=3)

    vector.set_data(np.vstack([ORIGIN, ORIGIN + M]))

    if t>10 and t<11:
        B = np.array([3.,1.,3.])
        # show the constant B field
        global created_second_b
        if not created_second_b:
            B_field_new = scene.visuals.Arrow(
                pos=np.vstack([ORIGIN, (ORIGIN + B)/magnitude(ORIGIN+B)]), #Normalize the B Field Bector
                width=2,
                color='red',
                parent=view.scene
            )
            created_second_b = True

    if t>11:
        B = np.array([1.,1.,5.])

    # vector.set_data(np.array([M[0],M[1],M[2]]))

from vispy import app
timer = app.Timer(interval='auto', connect=update, start=True)

if __name__ == '__main__':
    canvas.app.run()
