from vispy import scene
from vispy.visuals import transforms
from vispy import app
from vispy import io

import numpy as np

import signal
import sys

import threading ## Give the user control over the simulation!
shutdown = threading.Event()
save_next_frame = threading.Event()

name = ""
name_mutex = threading.Lock()

console_mutex = threading.Lock()

run_sim = threading.Event()

## Handle exits gracefully instead of throwing a system_crashed error on ^C
def handler(sig, frame):
    shutdown.set()

# register for Ctrl+C (SIGINT)
signal.signal(signal.SIGINT, handler)


### Helper Functions ###
def magnitude(vector):
    return np.sqrt(np.dot(vector,vector))

def cprint(*args, **kwargs):
    with console_mutex:
        print(*args, **kwargs)

### Simultation Configuration ###


# pulse variables
class Pulse_info:
    pulse_duration = 0
    pulse_start = -1
    pulse_onging = 0

pulse = Pulse_info()
pulse_mutex = threading.Lock()


B_device = np.array([1.,1.,5.]) # Magnetic Field Vector of the device (points in the positive z direction)
B_eff = B_device.copy()
B_eff_mutex = threading.Lock()

M = B_device/magnitude(B_device) # Net Magnitization Vector
M0 = magnitude(M)

class Sample:
    T2 = 0.5 # Transverse Relaxation Time Constant
    T1 = 1 # Longitudinal Relaxation Time Constant
    R1 = 1/T1 # Relaxtation constant
    R2 = 1/T2 # Relaxtation constant
    gamma = 10 # Gyromagnetic ratio
sample = Sample()

dt = 0.001 # change in time per step
ORIGIN = np.array([0,0,0]) # Origin of our world

## This function takes the current net magnetization, starting magnetization, B field, both decay constants and the gyromagnetic ratio
## It returns the differential of M computed via the Bloch equations
## This function appears to be highly sensitive to input for certain M,B,R,gamma values. I believe this is a sensitive dependence on
## initial conditions problem
def calculate_bloch_differentials(M:np.array, M0:np.array, B:np.array, R1:float, R2:float, gamma:float) -> np.array:
    with B_eff_mutex: ## entering critical section -- B must be invariant
        dmxdt = gamma*np.cross(M,B)[0] - R2*M[0]
        dmydt = gamma*np.cross(M,B)[1] - R2*M[1]
        dmzdt = gamma*np.cross(M,B)[2] - R1*(M[2]-M0)
    ## End critical section
    
    dM = np.array([dmxdt, dmydt, dmzdt])

    return dM

## This function computed the dext value of M after dt passes
def compute_next_state(M, M0, B, R1, R2, gamma) -> np.array:
    M += calculate_bloch_differentials(M,M0, B,R1,R2,gamma) * dt
    return M


### Graphics Setup (Generated by chatGPT from example code on vispy)
# Create a window and 3D camera


canvas = scene.SceneCanvas(keys='interactive', bgcolor='black', size=(800, 600), show=True)
view = canvas.central_widget.add_view()
view.camera = 'turntable'  # interactive orbit camera
### END GPT ZONE


# show the path that M takes through the scene
scatter = scene.visuals.Markers(parent=view.scene)

# track the location of M
vector = scene.visuals.Arrow(
        pos=np.vstack([ORIGIN, (ORIGIN + M)]), 
        width=2,
        color='cyan',
        parent=view.scene
    )

# show the constant B field
B_field = scene.visuals.Arrow(
        pos=np.vstack([ORIGIN, (ORIGIN + B_eff)/magnitude(ORIGIN+B_eff)]), #Normalize the B Field Bector
        width=2,
        color='red',
        parent=view.scene
    )

# axis = scene.visuals.XYZAxis(parent=view.scene)

plot_point = 0
PLOT_RATE = 2
points = []

t = 0
# Animation function â€” updates every frame
def update(event):
    global M
    global B_eff
    global plot_point
    global PLOT_RATE
    global t
    global name

    ## Check Syncronization Flags
    if shutdown.is_set():
        app.quit()
        ## Should not get bellow this line
        sys.exit(0)

    if save_next_frame.is_set():
        frame = canvas.render()
        with name_mutex:
            io.write_png(name, frame)
        save_next_frame.clear()
        cprint(f"Success: saved frame to {name}\n")
    
    if not run_sim.is_set():
        return

    t = event.elapsed

    # advance our simulation
    M = compute_next_state(M, M0, B_eff, sample.R1, sample.R2, sample.gamma)

    plot_point += 1
    plot_point %= PLOT_RATE
    PLOT_RATE = 2
    if plot_point == 0:
        points.append((M[0],M[1],M[2])) 
        plot = np.array(points)
        scatter.set_data(plot, face_color=(0.3,1,1), size=3)

    vector.set_data(np.vstack([ORIGIN, ORIGIN + M]))

    return

timer = app.Timer(interval='auto', connect=update, start=True)




def wait_on_pulse():
    global B_eff
    global pulse

    while pulse.pulse_start + pulse.pulse_duration >= t:
        pass

    # if the pulse is over -> shut off the rf magnetic field

    with B_eff_mutex: ## Begin critcal section
        B_eff = B_device.copy()
    ## End critical section


    with pulse_mutex: ## Begin critical section
        pulse.pulse_onging = False
    ## End critical section

    cprint(f"rf pulse shut off at t={t}")

    return

def pulse_system(duration, field:np.array=np.array([])):
    global B_eff
    global t
    global pulse
    global B_device
    # send in a pulse
    if field.any():
         with B_eff_mutex: ## Begin critcal section
            B_eff = field.copy()
        ## End critical section
    else:
        random_vec = np.array(np.random.rand(3))
        random_vec_norm = random_vec/magnitude(random_vec)

        with B_eff_mutex: ## Begin critcal section
            B_eff = random_vec_norm * 6
        ## End critical section
       
        
    
    with pulse_mutex: ## Begin critcal section
        pulse.pulse_start = t
        pulse.pulse_duration = duration
        pulse.pulse_ongoing = True
    ## End critcal section


    cprint(f"rf pulse is being deployed:\n"\
            f"     will have effective magnetic field {B_eff}\n"\
            f"     starting at t={pulse.pulse_start}\n"\
            f"     lasting for t={pulse.pulse_duration}")

    t2 = threading.Thread(target=wait_on_pulse, daemon=True)
    t2.start()

    return

    

def user_thread():
    global B_eff
    global B_device

    global t

    global pulse

    global M
    global M0

    global sample

    global name

    while True:
        if shutdown.is_set():
            return
        
        with console_mutex:
            args = input("\nNMR cmd >> ")

        # parse commands
        args = args.split(" ")

        if args[0] == "start":
            if run_sim.is_set():
                cprint("ERR: simulation already running...\n")
                continue
            run_sim.set()
            cprint("Starting simulation...\n")
            continue

        if args[0] == "config":
            if run_sim.is_set():
                cprint("ERR: simulation already running...\n")
                continue

            if len(args) == 1:
                cprint("Err: incorrect syntax. Try config (one of: B_DEV <Bx> <By> <Bz> or M <Bx> <By> <Bz> or T1 <value> or T1 <value>)")
                continue

            if args[1] == "B_DEV":
                m_args = np.array([float(x) for x in args[2:]])
                B_device = m_args.copy()
                B_eff = B_device.copy()
                B_field.set_data(np.vstack([ORIGIN, ORIGIN + B_device]))
                cprint(f"set B_device to {B_device}")
                continue

            if args[1] == "M":
                m_args = np.array([float(x) for x in args[2:]])
                M = m_args.copy()
                M0 = magnitude(M)
                vector.set_data(np.vstack([ORIGIN, ORIGIN + M]))
                cprint(f"set M to {M}, M0 to {M0}")
                continue

            if args[1] == "T1":
                T1 = float(args[2])
                R1 = 1/T1
                cprint(f"set T1 to {T1}, R1 to {R1}")
                continue

            if args[1] == "T2":
                sample.T2 = float(args[2])
                sample.R2 = 1/sample.T2
                cprint(f"set T2 to {sample.T2}, R2 to {sample.R2}")
                continue

            cprint("Err: incorrect syntax. Try config (one of: B_DEV <Bx> <By> <Bz> or M <Bx> <By> <Bz> or T1 <value> or T1 <value>)")
            continue

        if args[0]=="pulse":
            if pulse.pulse_onging:
                cprint("ERR: pulse in progress\n")
                continue

            if len(args) == 1:
                cprint("ERR: incorrect syntax. Try pulse <duration> or pulse <diration> <Bx> <By> <Bz>")
                continue

            pulse_args = [float(x) for x in args[1:]]
            if len(pulse_args) == 1:
                pulse_system(pulse_args[0])
                continue

            if len(pulse_args) == 4:
                rf_field = np.array(pulse_args[1:])
                pulse_system(pulse_args[0], rf_field)
                continue

            cprint("ERR: incorrect syntax. Try pulse <duration> or pulse <diration> <Bx> <By> <Bz>")
            continue

        if args[0] == "exit":
            shutdown.set()
            continue

        if args[0] == "capture":
            if len(args) == 1:
                cprint("ERR: incorrect syntax. Try capture filename")
                continue

            with name_mutex:
                name = args[1]
            save_next_frame.set()
            

            continue

        if args[0] == "help" or args[0] == "h":
            cprint( "----------------Help for AbelNMR System-----------------\n"\
                    "Version: 1.0.1 (2025)\n"\
                    "Developed by Abel Bellows for CHEM 10\n"\
                    "Commands:\n"
                    "     config: configure device variables (run config for more info)\n"
                    "     start: start the simulation\n"\
                    "     pulse: initiate an RF pulse into the system (run pulse for more info)\n"\
                    "     capture: capture a frame of the simulation (run capture for more info)\n"\
                    "     exit: exit the simulation\n"\
                    "     help/h: get help\n"\
                    "--------------------------------------------------------\n")
            continue
        
        cprint("the command you entered is not a valid command. for help type h\n")
            
    

if __name__ == '__main__':
    t1 = threading.Thread(target=user_thread, daemon=True)
    t1.start()
    canvas.app.run()
   
